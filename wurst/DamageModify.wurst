package DamageModify
import AbilityObjEditing
import DamageDetection
import OnUnitEnterLeave
import ObjectIdGenerator
import LinkedList
import HashMap
/*
	Never use both this and DamageType package.

	The system does not handle 0 damage events.
	
	Has several cases of possibly unexpected behavior:
	- Event Damage is set to .actualAmount, not .amount.
	- Actual amount can not go below zero.
	- Listeners are not notified of damage with actual amount equals to zero. 
	- Changes to Damage instance made in listeners or after the damage event are not considered.

	There will be output to debug stream if anything would go wrong,
	for example if system will fail to pass/catch Damage instance in between
	damage instance creation and it's handling (.deal() and .handle()).
	

	Examples:
	
	// Leech implementation #1
	function onLeechEffect1()
		let d = GetTriggerUnit().returnDamage(GetSpellTargetUnit(), LEECH_DAMAGE, true, 0)

		d.source.addHP(d.amount)
		d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

		d.releaseInstance()

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect1)

	// Leech implementation #2
	function onLeechEffect2()
		GetTriggerUnit().damage(GetSpellTargetUnit(), LEECH_DAMAGE, LEECH_ID)

	init
		registerSpellEffectEvent(LEECH_ID, function onLeechEffect2)
		addDamageListener() d ->
			if d.id == LEECH_ID	
				d.source.addHP(d.amount) // Leech effect implementation #2
				d.source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()

	// Simple damage resistance buff

	function onBuffEffect()
		let target = GetSpellTargetUnit()
		let effect = target.addEffect(Abilities.voodooAuraTarget, "origin")
		let cb = addTargetDamageModifier() d ->
			d.amount -= d.initial * .5
		doAfter(BUFF_DURATION) ->
			removeTargetDamageModifier(cb)
			effect.destr()

	init
		registerSpellEffectEvent(BUFF_ID, function onLeechEffect2)
*/

/** If Damage instance wasn't created by one of DamageModify package's functions
	(or `new Damage(...)`), then Damage.id would be set to this value */
@configurable public constant DAMAGE_ID_NONTRIGGERED = -1

/** Deals triggered damage from unit to target.
	ID can be specified - a value only to .
	Damage instance is saved and returned after being dealt.

	Is a helper for `new Damage(this, target, amount, spell, 0)..saveInstance()..modify()..deal()` */
public function unit.returnDamage(unit target, real amount, bool spell, int id) returns Damage
	return new Damage(this, target, amount, spell, id)..saveInstance()..modify()..deal()

/** These callbacks are used to modify the damage.

	They can be called zero or more times, so that their call is not guaranteed
	for every instance, still the usual case is one time per instance. */
public interface DamageModifier
	function modify(Damage d)

/** These callbacks are used to listen to the damage.

	They are called strictly once per every damage instance, guaranteed,
	but they are disabled to modify. */
public interface DamageListener
	function listen(Damage d)

let damageModifiers = new LinkedList<DamageModifier>
let targetUniqueModifiers = new HashMap<unit, LinkedList<DamageModifier>>
let sourceUniqueModifiers = new HashMap<unit, LinkedList<DamageModifier>>

let damageListeners = new LinkedList<DamageListener>
let targetUniqueListeners = new HashMap<unit, LinkedList<DamageListener>>
let sourceUniqueListeners = new HashMap<unit, LinkedList<DamageListener>>

public function addDamageModifier(DamageModifier cb) returns DamageModifier
	damageModifiers.add(cb)
	return cb

/** The modifier would be called only if damage target equals to given unit.
	This allows to save perfomance with unit-unique modifiers. 
	Remember to destroy the modifier after it's used.*/
public function addTargetDamageModifier(unit u, DamageModifier cb) returns DamageModifier
	if not targetUniqueModifiers.has(u)
		targetUniqueModifiers.put(u, new LinkedList<DamageModifier>)
	targetUniqueModifiers.get(u).add(cb)
	return cb
			
/** The modifier would be called only if damage source equals to given unit.
	This allows to save perfomance with unit-unique modifiers. 
	Remember to destroy the modifier after it's used.*/
public function addSourceDamageModifier(unit u, DamageModifier cb) returns DamageModifier
	if not sourceUniqueModifiers.has(u)
		sourceUniqueModifiers.put(u, new LinkedList<DamageModifier>)
	sourceUniqueModifiers.get(u).add(cb)
	return cb

public function removeDamageModifier(DamageModifier cb)
	damageModifiers.remove(cb)

public function removeTargetDamageModifier(unit u, DamageModifier cb)
	var list = targetUniqueModifiers.get(u)
	if list != null
		list.remove(cb)
		if list.isEmpty()
			targetUniqueModifiers.remove(u)
			destroy list

public function removeSourceDamageModifier(unit u, DamageModifier cb)
	var list = sourceUniqueModifiers.get(u)
	if list != null
		list.remove(cb)
		if list.isEmpty()
			sourceUniqueModifiers.remove(u)
			destroy list

public function addDamageListener(DamageListener cb) returns DamageListener
	damageListeners.add(cb)
	return cb

/** The listener would be called only if damage target equals to given unit.
	This allows to save perfomance with unit-unique listeners. 
	Remember to destroy the listener after it's used.*/
public function addTargetDamageListener(unit u, DamageListener cb) returns DamageListener
	if not targetUniqueListeners.has(u)
		targetUniqueListeners.put(u, new LinkedList<DamageListener>)
	targetUniqueListeners.get(u).add(cb)
	return cb
			
/** The listener would be called only if source target equals to given unit.
	This allows to save perfomance with unit-unique listeners. 
	Remember to destroy the listener after it's used.*/
public function addSourceDamageListener(unit u, DamageListener cb) returns DamageListener
	if not sourceUniqueListeners.has(u)
		sourceUniqueListeners.put(u, new LinkedList<DamageListener>)
	sourceUniqueListeners.get(u).add(cb)
	return cb

public function removeDamageListener(DamageListener cb)
	damageListeners.remove(cb)

public function removeTargetDamageListener(unit u, DamageListener cb)
	var list = targetUniqueListeners.get(u)
	if list != null
		list.remove(cb)
		if list.isEmpty()
			targetUniqueListeners.remove(u)
			destroy list

public function removeSourceDamageListener(unit u, DamageListener cb)
	var list = sourceUniqueListeners.get(u)
	if list != null
		list.remove(cb)
		if list.isEmpty()
			sourceUniqueListeners.remove(u)
			destroy list

public class Damage
	/** Should store source ability of the Damage.

		It is set in `new Damage` by user's value.
		Helper functions do set this to 0.

		If Damage instance wasn't created
		by one of DamageModify package's functions (or `new Damage(...)`),
		then this would be set to DAMAGE_ID_NONTRIGGERED */
	integer id

	/** Who is dealing the damage */
	unit source

	/** Who is recieving the damage */
	unit target

	/** If the Damage is of ATTACK_TYPE_NORMAL */
	bool spell

	/** What amount of damage was originally convieved */
	real initial

	/** What amount of damage was/will be dealt to `target`.
	
		"amount of damage" == "amount of HP to remove" */
	real amount
	
	/** Allows manual creation of Damage instance, which is then dealt
		through .deal() call, guaranteed passing it to modifiers and listeners.

		Consider also: .saveInstance(), .modify() before it's call.*/
	construct(unit source, unit target, real amount, bool isSpell, int id)
		this.source = source
		this.target = target
		this.initial = amount
		this.amount = amount
		spell = isSpell
		this.id = id

	protected real actualAmount = 0
	/** Returns the actual damage that was withdrawn from the unit.
		Becomes valid only for listeners and after the event. */
	function getActual() returns real
		return actualAmount

	/** Call this if you want to save the target.
		This means that target won't die from the damage,
		no matter how big `amount` would be */
	function preventDeath()
		doPreventDeath = true
	protected bool doPreventDeath = false

	/** Nullifies actual damage amount and stops it from being listened to. */
	function deflect()
		doPreventDeath = true
	protected bool doDeflect = false

	/** Returns true if the damage is going to kill or already have killed target */
	function isKillingBlow() returns bool
		return killingBlow or (not fired and target.getHP() - .406 < amount)

	/** It is set to true if the damage, when it was dealt, killed the target */
	protected bool killingBlow = false

	/** Increases `amount` of the damage by `initial * magnitude` */
	function addMultiplier(real magnitude)
		if not fired
			amount += initial * (magnitude - 1)

	/** Increases `amount` of the damage with given amount */
	function addAmount(real amount)
		if not fired
			this.amount += amount

	/** applies all modifiers to the damage instance once */
	function modify()
		for i in damageModifiers
			i.modify(this)

	protected static Damage dealingInstance = null
	/** applies user-created Damage instance */
	function deal()
		if not fired
			let temp = dealingInstance
			dealingInstance = this
			source.damageTarget(target, initial, spell ? ATTACK_TYPE_NORMAL : ATTACK_TYPE_CHAOS)
			dealingInstance = temp
			if not fired
				Log.debug("Damage.deal() has failed to pass the instance!")
		else
			Log.debug("Damage.deal() called on already fired damage!")

	/** Damage instances are automatically destroyed.
		Use this to protect them if you need an instance anyhow.
		
		You need then to use `releaseInstance()`
		in order to destroy the instance.

		This means that the instance will be destroyed
		when the last `releaseInstance()` is called on it */
	function saveInstance()
		wantSave += 1

	/** Releases Damage instance so it can be destroyed.
		It is destroyed immediately if nobody else had saved it */
	function releaseInstance()
		wantSave -= 1
		if fired and wantSave <= 0
			destroy this

	/** The counter inside saveInstance() and releaseInstance() */
	protected int wantSave = 0
	ondestroy
		if wantSave > 0
			Log.error("Damage instance was unsafely destroyed! Use .releaseInstance() instead!")

	/** If the damage was already dealt */
	private bool fired = false

	/** Runs all damageListeners */
	protected function notify()
		for i in damageListeners
			i.listen(this)
		fired = true

	protected static Damage previousDamage = null
	/** Returns the damage instance that was created on last Damage event.
		For both listeners and modifiers it is previous to callback argument.

		Allows to retrieve the instance right after unit.damageTarget() call,
		but it is not guaranteed. */
	static function getPrevious() returns Damage
		return previousDamage

function handler() returns bool
	let damage = GetEventDamage()
	if damage == 0
		return false

	var d = Damage.dealingInstance
	if d == null or d.source != GetEventDamageSource() or d.target != GetTriggerUnit() or damage < 0 != d.spell
		if d != null
			Log.debug("Damage.handler() has ignored a damage due to incorrect data!")
		d = new Damage(GetEventDamageSource(), GetTriggerUnit(), (damage < 0 ? -damage : damage), damage < 0, DAMAGE_ID_NONTRIGGERED)..saveInstance()
		d.modify() // So basically all non-triggered damage is modified once
	else
		Damage.dealingInstance = null // let no one else retrieve the same instance
		d.saveInstance()
	
	if d.doDeflect
		d.actualAmount = 0
		BlzSetEventDamage(0)
		return false

	let life = d.target.getHP()
	d.killingBlow = life - .406 < d.amount
	if d.killingBlow 
		if d.doPreventDeath
			d.killingBlow = false
			d.actualAmount = life - .406
		else
			d.actualAmount = life
	else
		d.actualAmount = d.amount

	if d.actualAmount < 0
		d.actualAmount = 0
	BlzSetEventDamage(d.actualAmount)

	if d.actualAmount == 0
		return false

	d.notify()

	if Damage.previousDamage != null
		Damage.previousDamage.releaseInstance()
	Damage.previousDamage = d

	return false

constant DAMAGE_TYPE_CHECK_ID = compiletime(ABIL_ID_GEN.next())
init
	onEnter() ->
		getEnterLeaveUnit()..addAbility(DAMAGE_TYPE_CHECK_ID)..makeAbilityPermanent(DAMAGE_TYPE_CHECK_ID, true)
	addOnDamageFunc(Condition(function handler))

	addDamageModifier() d ->
		if targetUniqueModifiers.has(d.target)
			for cb in targetUniqueModifiers.get(d.target)
				cb.modify(d)
		if sourceUniqueModifiers.has(d.source)
			for cb in sourceUniqueModifiers.get(d.source)
				cb.modify(d)
	addDamageListener() d ->
		if targetUniqueListeners.has(d.target)
			for cb in targetUniqueListeners.get(d.target)
				cb.listen(d)
		if sourceUniqueListeners.has(d.source)
			for cb in sourceUniqueListeners.get(d.source)
				cb.listen(d)
	onLeave() ->
		targetUniqueModifiers.remove(getEnterLeaveUnit())
		sourceUniqueModifiers.remove(getEnterLeaveUnit())
		targetUniqueListeners.remove(getEnterLeaveUnit())
		sourceUniqueListeners.remove(getEnterLeaveUnit())

@compiletime function generateAbility()
	new AbilityDefinitionRunedBracers(DAMAGE_TYPE_CHECK_ID)
		..setName("Runed Bracer Dummy")
		..setEditorSuffix("(DamageType)")
		..setItemAbility(false)
		..setDamageReduction(1, 2.)